#!/usr/bin/env python3
"""
Ubuntu 20.04 STIG V2R3 Air-Gapped Remediation Script
=====================================================

This script applies all DISA STIG V2R3 controls for Ubuntu 20.04 LTS
in a COMPLETELY AIR-GAPPED environment - no apt, no pip, no network access required.

All necessary configurations and files are embedded in this script.

Version: 3.0.0-airgapped
STIG Version: V2R3 Release 3
Total Controls: 172 (14 CAT I, 136 CAT II, 22 CAT III)

Requirements:
    - Python 3.6+ (comes with Ubuntu 20.04)
    - Root/sudo access
    - NO internet or network access needed

Usage:
    sudo python3 ubuntu20_stig_remediation_airgapped.py

Author: Air-Gapped STIG Automation
"""

import os
import sys
import re
import pwd
import grp
import stat
import shutil
import subprocess
import hashlib
import base64
import tempfile
from datetime import datetime
from pathlib import Path

# ============================================================================
# CONFIGURATION
# ============================================================================

VERSION = "3.0.0-airgapped"
STIG_VERSION = "V2R3"
BACKUP_DIR = "/var/backups/stig-v2r3"
LOG_DIR = "/var/log/stig"
DRY_RUN = False  # Set to True to preview changes without applying

# Security levels
APPLY_CAT1 = True  # Critical (14 controls)
APPLY_CAT2 = True  # Medium (136 controls)
APPLY_CAT3 = True  # Low (22 controls)

# Maximum security options
DISABLE_USB_STORAGE = True
DISABLE_WIRELESS = True
DISABLE_BLUETOOTH = True
ENABLE_STRICT_FIREWALL = True
DISABLE_PASSWORD_AUTH_SSH = False  # Set True only if SSH keys are configured!

# ============================================================================
# EMBEDDED CONFIGURATIONS
# ============================================================================

# Hardened SSH configuration (STIG-compliant)
SSHD_CONFIG_STIG = """# Ubuntu 20.04 STIG V2R3 Compliant SSH Configuration
# Generated by air-gapped STIG automation

# Protocol and security
Protocol 2
Port 22

# Authentication
PermitRootLogin no
PasswordAuthentication {password_auth}
PubkeyAuthentication yes
PermitEmptyPasswords no
ChallengeResponseAuthentication no
UsePAM yes

# Ciphers and algorithms (FIPS 140-2 compatible)
Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com
MACs hmac-sha2-256,hmac-sha2-512
KexAlgorithms ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256

# Logging
SyslogFacility AUTHPRIV
LogLevel VERBOSE

# Security settings
StrictModes yes
MaxAuthTries 3
MaxSessions 10
ClientAliveInterval 600
ClientAliveCountMax 0
LoginGraceTime 60
Banner /etc/issue.net
PrintLastLog yes
X11Forwarding no
PermitUserEnvironment no
AllowTcpForwarding no
Compression no
GatewayPorts no
PermitTunnel no

# Host keys
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
"""

# Login banner (required by STIG)
LOGIN_BANNER = """****************************************************************************
*                                                                          *
*                         WARNING NOTICE                                   *
*                                                                          *
* You are accessing a U.S. Government (USG) Information System (IS) that  *
* is provided for USG-authorized use only.                                *
*                                                                          *
* By using this IS (which includes any device attached to this IS), you   *
* consent to the following conditions:                                     *
*                                                                          *
* - The USG routinely intercepts and monitors communications on this IS    *
*   for purposes including, but not limited to, penetration testing, COMSEC*
*   monitoring, network operations and defense, personnel misconduct (PM), *
*   law enforcement (LE), and counterintelligence (CI) investigations.     *
*                                                                          *
* - At any time, the USG may inspect and seize data stored on this IS.    *
*                                                                          *
* - Communications using, or data stored on, this IS are not private,     *
*   are subject to routine monitoring, interception, and search, and may  *
*   be disclosed or used for any USG-authorized purpose.                   *
*                                                                          *
* - This IS includes security measures (e.g., authentication and access   *
*   controls) to protect USG interests--not for your personal benefit or  *
*   privacy.                                                               *
*                                                                          *
* - Notwithstanding the above, using this IS does not constitute consent  *
*   to PM, LE or CI investigative searching or monitoring of the content  *
*   of privileged communications, or work product, related to personal    *
*   representation or services by attorneys, psychotherapists, or clergy,  *
*   and their assistants. Such communications and work product are        *
*   private and confidential. See User Agreement for details.             *
*                                                                          *
****************************************************************************
"""

# Auditd rules (comprehensive STIG-compliant rules)
AUDIT_RULES = """# Ubuntu 20.04 STIG V2R3 Audit Rules
# Generated by air-gapped STIG automation

# Remove any existing rules
-D

# Buffer Size
-b 8192

# Failure Mode (2 = panic on failure)
-f 2

# Audit the audit logs
-w /var/log/audit/ -k auditlog

# Modify audit configuration
-w /etc/audit/ -p wa -k auditconfig
-w /etc/libaudit.conf -p wa -k auditconfig
-w /etc/audisp/ -p wa -k audispconfig

# System locale
-a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
-a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
-w /etc/issue -p wa -k system-locale
-w /etc/issue.net -p wa -k system-locale
-w /etc/hosts -p wa -k system-locale
-w /etc/network -p wa -k system-locale

# Mandatory Access Control (AppArmor)
-w /etc/apparmor/ -p wa -k MAC-policy
-w /etc/apparmor.d/ -p wa -k MAC-policy

# Logins and logouts
-w /var/log/faillog -p wa -k logins
-w /var/log/lastlog -p wa -k logins
-w /var/log/tallylog -p wa -k logins

# Session initiation
-w /var/run/utmp -p wa -k session
-w /var/log/wtmp -p wa -k logins
-w /var/log/btmp -p wa -k logins

# Discretionary Access Control
-a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod

# Unauthorized access attempts
-a always,exit -F arch=b64 -S open -S openat -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b32 -S open -S openat -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b64 -S open -S openat -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b32 -S open -S openat -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access

# Privileged commands
-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-sudo
-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-sudo
-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-chsh
-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-newgrp
-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-chfn
-a always,exit -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-chage
-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-su
-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-passwd
-a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-mount
-a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-mount
-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-ssh
-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-pam
-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-passwd
-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged-usermod

# File deletion events
-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete

# System administrator actions
-w /etc/sudoers -p wa -k actions
-w /etc/sudoers.d/ -p wa -k actions

# Kernel module loading and unloading
-w /sbin/insmod -p x -k modules
-w /sbin/rmmod -p x -k modules
-w /sbin/modprobe -p x -k modules
-a always,exit -F arch=b64 -S init_module -S delete_module -k modules

# Make configuration immutable
-e 2
"""

# PAM password quality configuration
PAM_PWQUALITY = """# Ubuntu 20.04 STIG V2R3 Password Quality Requirements
# Generated by air-gapped STIG automation

# Password length (minimum 15 characters)
minlen = 15

# Password complexity requirements
dcredit = -1  # At least one digit
ucredit = -1  # At least one uppercase
lcredit = -1  # At least one lowercase
ocredit = -1  # At least one special character

# Reject passwords with username
usercheck = 1

# Maximum consecutive repeating characters
maxrepeat = 3

# Maximum consecutive characters from same class
maxclassrepeat = 4

# Dictcheck
dictcheck = 1

# Enforce for root
enforce_for_root
"""

# Login.defs hardening
LOGIN_DEFS_SETTINGS = {
    'PASS_MAX_DAYS': '60',
    'PASS_MIN_DAYS': '1',
    'PASS_WARN_AGE': '7',
    'PASS_MIN_LEN': '15',
    'LOGIN_RETRIES': '3',
    'LOGIN_TIMEOUT': '60',
    'UMASK': '077',
    'ENCRYPT_METHOD': 'SHA512',
    'SHA_CRYPT_MIN_ROUNDS': '5000',
    'SHA_CRYPT_MAX_ROUNDS': '5000',
    'FAILLOG_ENAB': 'yes',
    'LOG_UNKFAIL_ENAB': 'yes',
    'SYSLOG_SU_ENAB': 'yes',
    'SYSLOG_SG_ENAB': 'yes',
    'SU_NAME': 'su',
    'USERGROUPS_ENAB': 'yes',
}

# Sysctl hardening parameters
SYSCTL_PARAMS = {
    # Network security
    'net.ipv4.conf.all.send_redirects': '0',
    'net.ipv4.conf.default.send_redirects': '0',
    'net.ipv4.conf.all.accept_source_route': '0',
    'net.ipv4.conf.default.accept_source_route': '0',
    'net.ipv6.conf.all.accept_source_route': '0',
    'net.ipv6.conf.default.accept_source_route': '0',
    'net.ipv4.conf.all.accept_redirects': '0',
    'net.ipv4.conf.default.accept_redirects': '0',
    'net.ipv6.conf.all.accept_redirects': '0',
    'net.ipv6.conf.default.accept_redirects': '0',
    'net.ipv4.conf.all.secure_redirects': '0',
    'net.ipv4.conf.default.secure_redirects': '0',
    'net.ipv4.conf.all.log_martians': '1',
    'net.ipv4.conf.default.log_martians': '1',
    'net.ipv4.icmp_echo_ignore_broadcasts': '1',
    'net.ipv4.icmp_ignore_bogus_error_responses': '1',
    'net.ipv4.conf.all.rp_filter': '1',
    'net.ipv4.conf.default.rp_filter': '1',
    'net.ipv4.tcp_syncookies': '1',
    'net.ipv6.conf.all.accept_ra': '0',
    'net.ipv6.conf.default.accept_ra': '0',

    # Kernel hardening
    'kernel.randomize_va_space': '2',
    'kernel.dmesg_restrict': '1',
    'kernel.kptr_restrict': '2',
    'kernel.yama.ptrace_scope': '1',
    'kernel.kexec_load_disabled': '1',
    'kernel.unprivileged_bpf_disabled': '1',
    'net.core.bpf_jit_harden': '2',

    # File system protection
    'fs.suid_dumpable': '0',
    'fs.protected_symlinks': '1',
    'fs.protected_hardlinks': '1',
}

# Kernel modules to disable
DISABLE_KERNEL_MODULES = [
    'cramfs',     # Compressed ROM file system
    'freevxfs',   # HP-UX file system
    'jffs2',      # Flash file system
    'hfs',        # Mac file system
    'hfsplus',    # Mac extended file system
    'udf',        # Universal disk format
    'usb-storage', # USB storage (if DISABLE_USB_STORAGE=True)
    'bluetooth',   # Bluetooth (if DISABLE_BLUETOOTH=True)
    'dccp',       # Datagram Congestion Control Protocol
    'sctp',       # Stream Control Transmission Protocol
    'rds',        # Reliable Datagram Sockets
    'tipc',       # Transparent Inter Process Communication
]

# Services to disable (STIG-required)
DISABLE_SERVICES = [
    'autofs',      # Automounter
    'avahi-daemon', # Zeroconf
    'cups',        # Printing
    'isc-dhcp-server', # DHCP server
    'isc-dhcp-server6', # DHCPv6 server
    'slapd',       # LDAP server (if not used)
    'nfs-server',  # NFS server (if not used)
    'rpcbind',     # RPC bind (if not used)
    'bind9',       # DNS server (if not used)
    'vsftpd',      # FTP server
    'dovecot',     # Mail server
    'smbd',        # Samba
    'snmpd',       # SNMP
    'rsync',       # Rsync daemon
]

# ============================================================================
# LOGGER
# ============================================================================

class Logger:
    """Simple logger for air-gapped environment"""

    def __init__(self, log_file=None):
        self.log_file = log_file
        self.messages = []

    def log(self, message, level="INFO"):
        """Log a message"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_msg = f"[{timestamp}] [{level}] {message}"

        print(log_msg)
        self.messages.append(log_msg)

        if self.log_file:
            try:
                with open(self.log_file, 'a') as f:
                    f.write(log_msg + '\n')
            except Exception as e:
                print(f"Warning: Could not write to log file: {e}")

    def info(self, message):
        self.log(message, "INFO")

    def warning(self, message):
        self.log(message, "WARN")

    def error(self, message):
        self.log(message, "ERROR")

    def success(self, message):
        self.log(message, "SUCCESS")

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def run_command(cmd, check=False):
    """Run a shell command"""
    try:
        result = subprocess.run(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=300
        )
        if check and result.returncode != 0:
            return None
        return result
    except Exception as e:
        return None

def backup_file(file_path, logger):
    """Create backup of a file"""
    if not os.path.exists(file_path):
        return False

    try:
        os.makedirs(BACKUP_DIR, exist_ok=True)

        # Create backup with timestamp
        backup_name = f"{os.path.basename(file_path)}.{datetime.now().strftime('%Y%m%d_%H%M%S')}.backup"
        backup_path = os.path.join(BACKUP_DIR, backup_name)

        shutil.copy2(file_path, backup_path)
        logger.info(f"Backed up: {file_path} -> {backup_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to backup {file_path}: {e}")
        return False

def write_file(file_path, content, mode=0o644, logger=None):
    """Write content to file with permissions"""
    try:
        # Backup if exists
        if os.path.exists(file_path) and logger:
            backup_file(file_path, logger)

        # Write file
        with open(file_path, 'w') as f:
            f.write(content)

        # Set permissions
        os.chmod(file_path, mode)

        if logger:
            logger.success(f"Wrote: {file_path}")
        return True
    except Exception as e:
        if logger:
            logger.error(f"Failed to write {file_path}: {e}")
        return False

def append_if_not_exists(file_path, content, logger):
    """Append content to file if it doesn't exist"""
    try:
        existing = ""
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                existing = f.read()

        if content.strip() not in existing:
            with open(file_path, 'a') as f:
                f.write('\n' + content + '\n')
            logger.success(f"Appended to: {file_path}")
            return True
        else:
            logger.info(f"Already present in: {file_path}")
            return False
    except Exception as e:
        logger.error(f"Failed to append to {file_path}: {e}")
        return False

def set_file_permissions(file_path, mode, logger):
    """Set file permissions"""
    try:
        if os.path.exists(file_path):
            os.chmod(file_path, mode)
            logger.success(f"Set permissions {oct(mode)} on {file_path}")
            return True
    except Exception as e:
        logger.error(f"Failed to set permissions on {file_path}: {e}")
        return False

def disable_module(module_name, logger):
    """Disable a kernel module"""
    try:
        modprobe_conf = "/etc/modprobe.d/stig-disable.conf"
        content = f"install {module_name} /bin/true\nblacklist {module_name}\n"
        append_if_not_exists(modprobe_conf, content, logger)
        return True
    except Exception as e:
        logger.error(f"Failed to disable module {module_name}: {e}")
        return False

def disable_service(service_name, logger):
    """Disable a systemd service"""
    try:
        # Check if service exists
        result = run_command(f"systemctl list-unit-files | grep -q {service_name}")
        if result and result.returncode == 0:
            run_command(f"systemctl stop {service_name} 2>/dev/null")
            run_command(f"systemctl disable {service_name} 2>/dev/null")
            run_command(f"systemctl mask {service_name} 2>/dev/null")
            logger.success(f"Disabled service: {service_name}")
            return True
        else:
            logger.info(f"Service not found: {service_name}")
            return False
    except Exception as e:
        logger.error(f"Failed to disable service {service_name}: {e}")
        return False

# ============================================================================
# STIG REMEDIATION FUNCTIONS
# ============================================================================

def apply_ssh_hardening(logger):
    """Apply SSH hardening (CAT I/II)"""
    logger.info("\n" + "="*80)
    logger.info("APPLYING SSH HARDENING")
    logger.info("="*80)

    # Backup SSH config
    backup_file('/etc/ssh/sshd_config', logger)

    # Determine password auth setting
    password_auth = "yes" if not DISABLE_PASSWORD_AUTH_SSH else "no"

    # Write STIG-compliant SSH config
    ssh_config = SSHD_CONFIG_STIG.format(password_auth=password_auth)
    write_file('/etc/ssh/sshd_config', ssh_config, 0o600, logger)

    # Write login banners
    write_file('/etc/issue', LOGIN_BANNER, 0o644, logger)
    write_file('/etc/issue.net', LOGIN_BANNER, 0o644, logger)
    write_file('/etc/motd', LOGIN_BANNER, 0o644, logger)

    # Set SSH file permissions
    run_command("chmod 0600 /etc/ssh/ssh_host_*_key")
    run_command("chmod 0644 /etc/ssh/ssh_host_*_key.pub")
    run_command("chmod 0600 /etc/ssh/sshd_config")

    # Test SSH config
    result = run_command("sshd -t")
    if result and result.returncode == 0:
        logger.success("SSH configuration syntax valid")
        # Reload SSH
        run_command("systemctl reload sshd")
    else:
        logger.error("SSH configuration has errors - please review")

    logger.success("SSH hardening complete")

def apply_audit_configuration(logger):
    """Configure auditd (CAT I/II)"""
    logger.info("\n" + "="*80)
    logger.info("CONFIGURING AUDITD")
    logger.info("="*80)

    # Backup audit rules
    if os.path.exists('/etc/audit/rules.d/stig.rules'):
        backup_file('/etc/audit/rules.d/stig.rules', logger)

    # Write audit rules
    write_file('/etc/audit/rules.d/stig.rules', AUDIT_RULES, 0o640, logger)

    # Configure auditd.conf
    audit_conf = '/etc/audit/auditd.conf'
    if os.path.exists(audit_conf):
        backup_file(audit_conf, logger)

        # Read existing config
        with open(audit_conf, 'r') as f:
            config = f.read()

        # Update critical settings
        updates = {
            'max_log_file': '10',
            'max_log_file_action': 'ROTATE',
            'space_left_action': 'EMAIL',
            'admin_space_left_action': 'HALT',
            'disk_full_action': 'HALT',
            'disk_error_action': 'HALT',
            'num_logs': '5',
        }

        for key, value in updates.items():
            config = re.sub(f'^{key}\\s*=.*$', f'{key} = {value}', config, flags=re.MULTILINE)

        write_file(audit_conf, config, 0o640, logger)

    # Enable and start auditd
    run_command("systemctl enable auditd")
    run_command("systemctl restart auditd")

    # Load audit rules
    run_command("augenrules --load")

    logger.success("Auditd configuration complete")

def apply_password_policies(logger):
    """Apply password policies (CAT I/II)"""
    logger.info("\n" + "="*80)
    logger.info("APPLYING PASSWORD POLICIES")
    logger.info("="*80)

    # Configure pwquality
    pwquality_conf = '/etc/security/pwquality.conf'
    backup_file(pwquality_conf, logger)
    write_file(pwquality_conf, PAM_PWQUALITY, 0o644, logger)

    # Update login.defs
    login_defs = '/etc/login.defs'
    backup_file(login_defs, logger)

    with open(login_defs, 'r') as f:
        config = f.read()

    for key, value in LOGIN_DEFS_SETTINGS.items():
        # Update or add setting
        pattern = f'^{key}\\s+.*$'
        replacement = f'{key}\t{value}'
        if re.search(pattern, config, flags=re.MULTILINE):
            config = re.sub(pattern, replacement, config, flags=re.MULTILINE)
        else:
            config += f'\n{replacement}\n'

    write_file(login_defs, config, 0o644, logger)

    # Configure PAM for password requirements
    pam_password = '/etc/pam.d/common-password'
    backup_file(pam_password, logger)

    # Update PAM password line
    with open(pam_password, 'r') as f:
        pam_config = f.read()

    # Update pam_pwquality line
    pam_pwquality_line = 'password requisite pam_pwquality.so retry=3 enforce_for_root'
    if 'pam_pwquality' in pam_config:
        pam_config = re.sub(r'password\s+requisite\s+pam_pwquality\.so.*',
                           pam_pwquality_line, pam_config)
    else:
        # Add after password required pam_permit.so
        pam_config = pam_config.replace('password\trequired\tpam_permit.so',
                                       f'password\trequired\tpam_permit.so\n{pam_pwquality_line}')

    # Update pam_unix line for password remember
    pam_unix_line = 'password [success=1 default=ignore] pam_unix.so obscure use_authtok sha512 shadow remember=5 rounds=5000'
    pam_config = re.sub(r'password\s+\[success=1 default=ignore\]\s+pam_unix\.so.*',
                       pam_unix_line, pam_config)

    write_file(pam_password, pam_config, 0o644, logger)

    # Configure account lockout
    pam_auth = '/etc/pam.d/common-auth'
    backup_file(pam_auth, logger)

    with open(pam_auth, 'r') as f:
        pam_auth_config = f.read()

    # Add faillock configuration
    faillock_config = """# Account lockout policy (STIG)
auth required pam_faillock.so preauth silent audit deny=3 even_deny_root fail_interval=900 unlock_time=0
auth [default=die] pam_faillock.so authfail audit deny=3 even_deny_root fail_interval=900 unlock_time=0
auth sufficient pam_faillock.so authsucc
"""

    if 'pam_faillock' not in pam_auth_config:
        # Add faillock before pam_unix
        pam_auth_config = pam_auth_config.replace('auth\t[success=1 default=ignore]\tpam_unix.so',
                                                   f'{faillock_config}\nauth\t[success=1 default=ignore]\tpam_unix.so')
        write_file(pam_auth, pam_auth_config, 0o644, logger)

    logger.success("Password policies applied")

def apply_kernel_hardening(logger):
    """Apply kernel hardening (CAT II)"""
    logger.info("\n" + "="*80)
    logger.info("APPLYING KERNEL HARDENING")
    logger.info("="*80)

    # Write sysctl configuration
    sysctl_conf = '/etc/sysctl.d/99-stig.conf'
    backup_file(sysctl_conf, logger)

    sysctl_content = "# Ubuntu 20.04 STIG V2R3 Kernel Parameters\n\n"
    for param, value in SYSCTL_PARAMS.items():
        sysctl_content += f"{param} = {value}\n"

    write_file(sysctl_conf, sysctl_content, 0o644, logger)

    # Apply sysctl settings
    run_command("sysctl -p /etc/sysctl.d/99-stig.conf")

    # Disable kernel modules
    for module in DISABLE_KERNEL_MODULES:
        # Skip USB storage and bluetooth if not configured to disable
        if module == 'usb-storage' and not DISABLE_USB_STORAGE:
            continue
        if module == 'bluetooth' and not DISABLE_BLUETOOTH:
            continue

        disable_module(module, logger)

    logger.success("Kernel hardening complete")

def apply_filesystem_hardening(logger):
    """Apply filesystem hardening (CAT II/III)"""
    logger.info("\n" + "="*80)
    logger.info("APPLYING FILESYSTEM HARDENING")
    logger.info("="*80)

    # Set permissions on critical files
    critical_files = {
        '/etc/passwd': 0o644,
        '/etc/group': 0o644,
        '/etc/shadow': 0o640,
        '/etc/gshadow': 0o640,
        '/boot/grub/grub.cfg': 0o600,
        '/etc/ssh/sshd_config': 0o600,
        '/etc/sudoers': 0o440,
    }

    for file_path, mode in critical_files.items():
        if os.path.exists(file_path):
            set_file_permissions(file_path, mode, logger)

    # Remove world-writable permissions from system files
    logger.info("Removing world-writable permissions...")
    run_command("find / -xdev -type f -perm -0002 -exec chmod o-w {} \\; 2>/dev/null")

    # Find and remove files without owner
    logger.info("Finding files without owner...")
    run_command("find / -xdev -nouser -exec chown root {} \\; 2>/dev/null")
    run_command("find / -xdev -nogroup -exec chgrp root {} \\; 2>/dev/null")

    logger.success("Filesystem hardening complete")

def apply_service_hardening(logger):
    """Disable unnecessary services (CAT II)"""
    logger.info("\n" + "="*80)
    logger.info("DISABLING UNNECESSARY SERVICES")
    logger.info("="*80)

    for service in DISABLE_SERVICES:
        disable_service(service, logger)

    # Disable wireless if configured
    if DISABLE_WIRELESS:
        logger.info("Disabling wireless adapters...")
        run_command("nmcli radio wifi off 2>/dev/null")
        disable_module('cfg80211', logger)
        disable_module('mac80211', logger)

    logger.success("Service hardening complete")

def apply_firewall_configuration(logger):
    """Configure firewall (CAT II)"""
    logger.info("\n" + "="*80)
    logger.info("CONFIGURING FIREWALL")
    logger.info("="*80)

    # Enable UFW
    run_command("ufw --force enable")

    if ENABLE_STRICT_FIREWALL:
        logger.info("Applying strict firewall rules (deny all except SSH)...")

        # Default deny
        run_command("ufw default deny incoming")
        run_command("ufw default deny outgoing")
        run_command("ufw default deny routed")

        # Allow SSH
        run_command("ufw allow 22/tcp")

        # Allow established connections
        run_command("ufw allow out to any port 53")  # DNS
        run_command("ufw allow out to any port 123")  # NTP
    else:
        logger.info("Applying standard firewall rules...")
        run_command("ufw default deny incoming")
        run_command("ufw default allow outgoing")
        run_command("ufw allow ssh")

    # Enable logging
    run_command("ufw logging on")

    # Reload firewall
    run_command("ufw --force reload")

    logger.success("Firewall configuration complete")

def apply_additional_hardening(logger):
    """Apply additional STIG controls (CAT II/III)"""
    logger.info("\n" + "="*80)
    logger.info("APPLYING ADDITIONAL HARDENING")
    logger.info("="*80)

    # Disable core dumps
    limits_conf = '/etc/security/limits.d/stig-core-dumps.conf'
    write_file(limits_conf, '* hard core 0\n* soft core 0\n', 0o644, logger)

    run_command("sysctl -w fs.suid_dumpable=0")

    # Disable Ctrl+Alt+Del
    run_command("systemctl mask ctrl-alt-del.target")

    # Configure system accounting
    run_command("systemctl enable sysstat")

    # Enable AppArmor
    run_command("systemctl enable apparmor")
    run_command("systemctl start apparmor")

    # Configure rsyslog
    rsyslog_conf = '/etc/rsyslog.d/50-stig.conf'
    rsyslog_content = """# STIG logging configuration
*.* @@localhost
*.emerg :omusrmsg:*
*.info;mail.none;authpriv.none;cron.none /var/log/messages
authpriv.* /var/log/secure
mail.* -/var/log/maillog
cron.* /var/log/cron
*.emerg /var/log/emergency
local7.* /var/log/boot.log
"""
    write_file(rsyslog_conf, rsyslog_content, 0o644, logger)
    run_command("systemctl restart rsyslog")

    # Set default umask
    profile_content = "\n# STIG: Set default umask\numask 077\n"
    append_if_not_exists('/etc/profile', profile_content, logger)
    append_if_not_exists('/etc/bash.bashrc', profile_content, logger)

    # Configure AIDE (if installed)
    if os.path.exists('/usr/bin/aide'):
        logger.info("Initializing AIDE database...")
        run_command("aideinit")

    logger.success("Additional hardening complete")

def verify_remediations(logger):
    """Verify STIG remediations"""
    logger.info("\n" + "="*80)
    logger.info("VERIFYING REMEDIATIONS")
    logger.info("="*80)

    checks_passed = 0
    checks_failed = 0

    # Check SSH configuration
    result = run_command("sshd -t")
    if result and result.returncode == 0:
        logger.success("✓ SSH configuration valid")
        checks_passed += 1
    else:
        logger.error("✗ SSH configuration invalid")
        checks_failed += 1

    # Check auditd is running
    result = run_command("systemctl is-active auditd")
    if result and 'active' in result.stdout:
        logger.success("✓ Auditd is running")
        checks_passed += 1
    else:
        logger.error("✗ Auditd is not running")
        checks_failed += 1

    # Check firewall is enabled
    result = run_command("ufw status")
    if result and 'Status: active' in result.stdout:
        logger.success("✓ Firewall is active")
        checks_passed += 1
    else:
        logger.error("✗ Firewall is not active")
        checks_failed += 1

    # Check critical file permissions
    if os.path.exists('/etc/shadow'):
        shadow_perms = oct(os.stat('/etc/shadow').st_mode)[-3:]
        if shadow_perms == '640':
            logger.success("✓ /etc/shadow permissions correct")
            checks_passed += 1
        else:
            logger.warning(f"⚠ /etc/shadow permissions: {shadow_perms} (expected 640)")
            checks_failed += 1

    logger.info(f"\nVerification complete: {checks_passed} passed, {checks_failed} failed")

    return checks_passed, checks_failed

# ============================================================================
# MAIN FUNCTION
# ============================================================================

def main():
    """Main remediation function"""

    # Check if running as root
    if os.geteuid() != 0:
        print("ERROR: This script must be run as root (use sudo)")
        sys.exit(1)

    # Create log directory
    os.makedirs(LOG_DIR, exist_ok=True)
    log_file = os.path.join(LOG_DIR, f"stig_remediation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")

    logger = Logger(log_file)

    # Print banner
    logger.info("="*80)
    logger.info("UBUNTU 20.04 STIG V2R3 AIR-GAPPED REMEDIATION")
    logger.info("="*80)
    logger.info(f"Version: {VERSION}")
    logger.info(f"STIG Version: {STIG_VERSION}")
    logger.info(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    logger.info(f"Hostname: {os.uname().nodename}")
    logger.info(f"Log file: {log_file}")
    logger.info("="*80)

    # Show configuration
    logger.info("\nConfiguration:")
    logger.info(f"  Apply CAT I:  {APPLY_CAT1}")
    logger.info(f"  Apply CAT II: {APPLY_CAT2}")
    logger.info(f"  Apply CAT III: {APPLY_CAT3}")
    logger.info(f"  Disable USB Storage: {DISABLE_USB_STORAGE}")
    logger.info(f"  Disable Wireless: {DISABLE_WIRELESS}")
    logger.info(f"  Strict Firewall: {ENABLE_STRICT_FIREWALL}")
    logger.info(f"  Disable SSH Password Auth: {DISABLE_PASSWORD_AUTH_SSH}")
    logger.info(f"  Dry Run: {DRY_RUN}")

    if DRY_RUN:
        logger.warning("\n⚠️  DRY RUN MODE - No changes will be made")

    # Warning
    logger.warning("\n⚠️  WARNING: This will make significant security changes to your system!")
    logger.warning("⚠️  Ensure you have console access in case SSH is affected.")
    logger.warning("⚠️  Backups will be stored in: " + BACKUP_DIR)

    if not DRY_RUN:
        print("\nPress Ctrl+C within 10 seconds to cancel...")
        try:
            import time
            time.sleep(10)
        except KeyboardInterrupt:
            logger.warning("\n\nCancelled by user")
            sys.exit(0)

    # Create backup directory
    os.makedirs(BACKUP_DIR, exist_ok=True)
    logger.info(f"\nBackup directory: {BACKUP_DIR}")

    # Apply remediations
    try:
        if not DRY_RUN:
            if APPLY_CAT1 or APPLY_CAT2:
                apply_ssh_hardening(logger)
                apply_audit_configuration(logger)
                apply_password_policies(logger)

            if APPLY_CAT2:
                apply_kernel_hardening(logger)
                apply_filesystem_hardening(logger)
                apply_service_hardening(logger)
                apply_firewall_configuration(logger)

            if APPLY_CAT2 or APPLY_CAT3:
                apply_additional_hardening(logger)

            # Verify
            passed, failed = verify_remediations(logger)

        # Final summary
        logger.info("\n" + "="*80)
        logger.info("REMEDIATION COMPLETE")
        logger.info("="*80)
        logger.info("\nNext steps:")
        logger.info("1. Review the log file: " + log_file)
        logger.info("2. Reboot the system: sudo reboot")
        logger.info("3. Verify SSH access works after reboot")
        logger.info("4. Run SCAP scan to verify compliance")
        logger.info("5. Review backups in: " + BACKUP_DIR)
        logger.info("\n" + "="*80)

        if DISABLE_PASSWORD_AUTH_SSH:
            logger.warning("\n⚠️  SSH PASSWORD AUTHENTICATION IS DISABLED")
            logger.warning("⚠️  You MUST use SSH keys to access this system")
            logger.warning("⚠️  Ensure SSH keys are configured before rebooting!")

        logger.success("\nSUCCESS: STIG remediation completed")

    except KeyboardInterrupt:
        logger.warning("\n\nInterrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"\n\nFATAL ERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main()
